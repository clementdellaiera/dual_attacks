load("Distinguisher/dual_attack.sage")

################
##   BASICS   ##
################

# Generating q-ary lattice of dimension 100 and determinant q**50, where q is a 30 bit prime
n=10
#AA = IntegerMatrix.random(n , "qary", k = 50 , bits = 30)
## Generating SIS instance
q = 37
AA = random_matrix(Zmod(q),n)

###############
##   TESTS   ## 
###############

# Parameters

n=10

# LATTICES
print("** LATTICES **")

A = random_matrix(ZZ,n,n)
#s, e = random_vector(ZZ , n ), random_vector(ZZ , n ) 
#t = A*s+e

print("")
print("** BKZ **")

print("norm of first vector of A")
print(A[1].norm())

print("BKZ reduction of A")
print("Norm of the first vector of reduced basis : "+str(A.BKZ()[1].norm()))

print("")
print("**  DUAL  **") 

# IntegralLattice returns the lattice generated by a quadratic form over ZZ

LL = IntegralLattice(A.transpose() * A) # for integal lattice, there is a direct method
LLv = LL.dual_lattice()
#print(LL.parent())
#print(LL.dual_lattice().parent())

L = A.image()
Av = A * (A.transpose()*A).inverse()
Lv = Av.image() # problem : this is considered a rationnal vector space, not a lattice
w , v = Lv.random_element() , L.random_element()
print(" (w ,v) in ZZ : "+str( w.dot_product(v) in ZZ))

dd = det(A)
B = dd * A.inverse().transpose()
B = B.change_ring(ZZ)
dLv = B.image()
ww , v = (1/dd) * dLv.random_element() , L.random_element()
print(" (w ,v) in ZZ : "+str( ww.dot_product(v) in ZZ))
vol , Av, Lv = Dual(A)
print("Dual Test : "+str(Lv == (1/dd) * dLv))
	
ss, (AA,bb) = LWE(20)	

N = 100	
XX = np.random.normal(0,1,N)

print("Distinguisher TEST : "+str(Test(XX , 0.1)))

print("")
mm = 10 			# rank of lattice
kk = 4 				# k first vectors in BKZ reduction of dual basis
TT = 10				# scale of the dual sample
BB = random_matrix(ZZ,mm) 	# Basis of lattice

################################
##    Test for Dual Sampler   ##
################################

print("SAMPLE Test : sample of "+str(TT)+" vectors over dual lattice of rank " + str(mm))

print("Random independant draw with replacement")
SAMPLE = Sample_Dual(BB, kk , TT, "Random_with_replacement")
success = 0
for w in SAMPLE:
	v = BB.image().random_element()
	if (w.dot_product(v) in ZZ):
		success += 1
print("Test (w,v) in ZZ : "+str(100 * success / len(SAMPLE)) + " % success for "+str(len(SAMPLE))+" dual vectors")

print("Random Walk")
SAMPLE = Sample_Dual(BB, kk , TT, "Random_walk")
success = 0
for w in SAMPLE:
	v = BB.image().random_element()
	if (w.dot_product(v) in ZZ):
		success += 1
print("Test (w,v) in ZZ : "+str(100 * success / len(SAMPLE)) + " % success for "+str(len(SAMPLE))+" dual vectors")

print("Sieve")
SAMPLE = Sample_Dual(BB, kk , TT, "Sieve")
success = 0
for w in SAMPLE:
	v = BB.image().random_element()
	if (w.dot_product(v) in ZZ):
		success += 1
print("Test (w,v) in ZZ : "+str(100 * success / len(SAMPLE)) + " % success for "+str(len(SAMPLE))+" dual vectors")
print("")

###############################
##   Test for distinguiser   ##
###############################
print("")
print("DISTINGUISHER test")
tt = LWE_sample(BB,0.1)
print(Distinguisher_Sieve(BB ,tt, kk,TT))

tt_uniform = vector(RR, normal(0,200,mm))
print(Distinguisher_Sieve(BB ,tt_uniform, kk,TT))
##################################
##   Hadamard Walsh Transform   ##
##################################

from sympy import fwht
from numpy import cos, linspace
m=10
t = linspace(0,1,2**m)
f = cos(t)
Ff = fwht(f)
e = 0.00000001
print("FAST HADAMARD WALSH TRANSFORM")
print("Check that F**2 = id : "+str(sum(1*(abs(fwht(Ff)-2**m * f) < e)) == 2**m ))


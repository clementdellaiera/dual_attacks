

# This file was *autogenerated* from the file Dual_short_vectors.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_p95 = RealNumber('.95'); _sage_const_1p7 = RealNumber('1.7'); _sage_const_5 = Integer(5); _sage_const_p5 = RealNumber('.5'); _sage_const_2p = RealNumber('2.')
from fpylll import IntegerMatrix
from fpylll.util import gaussian_heuristic
from g6k import Siever 

##   Load lattice basis 
[ is_LWE , rank , modulus , log_covolume ] , B = load('Lattice_basis/basis_LWE.sobj')

## Basis of dual/perpendicular lattice
if is_LWE :
	m = rank - log_covolume
	A = matrix(ZZ,B)[_sage_const_0 :log_covolume, m:rank]
	"""
	If B = [[I_m | A ] , [0 | q I_k]] , then
		B is a basis of Lq(A) 
		Bv = [[I_m | 0 ],[ -(1/q) * A | (1/q) * I_k ]] 	is a basis of dual(Lq(A))
		Bperp = [[q * I_m | 0 ] , [ - A | I_k ]]	is a basis of perp(Lq(A)) 
	"""
	B_perp = block_matrix( [ [modulus * matrix.identity(ZZ,m) , matrix.zero(ZZ ,m , log_covolume )] , [ - A.transpose() , matrix.identity(ZZ , log_covolume)] ] )
	B_perp = IntegerMatrix.from_matrix(B_perp)
else :
	assert False , "Code not done yet"
	det_B , inverse_matrix = det(B) ,  
	Bv = B.inverse().transpose()

###############################################################
##     Dual short vectors of dual/perp lattice via sieve     ##
##   Modification of g6k example file all_short_vectors.py   ##
###############################################################
short_vector_list = []	
	
g6k = Siever(B_perp)
g6k.lll(_sage_const_0 ,rank)

g6k.initialize_local(_sage_const_0 , rank /_sage_const_2 , rank)
while g6k.l > _sage_const_0 :
    # Extend the lift context to the left
    g6k.extend_left(_sage_const_1 )
    # Sieve
    g6k()

with g6k.temp_params(saturation_ratio=_sage_const_p95 , saturation_radius=_sage_const_1p7 , 
                     db_size_base=sqrt(_sage_const_1p7 ), db_size_factor=_sage_const_5 ):
    g6k()

# Convert all data_base vectors from basis A to cannonical basis and print them 
# out if they are indeed shorter than 1.7 * gh^2

gh = gaussian_heuristic([g6k.M.get_r(i, i) for i in range(rank)])

data_base = list(g6k.itervalues())
found = _sage_const_0 

for x in data_base:
    v = B_perp.multiply_left(x)
    l = sum(v_**_sage_const_2  for v_ in v)
    if l < _sage_const_1p7  * gh:
        # print(l/gh, v)
        found += _sage_const_1 
        short_vector_list.append(v)

print("Found %d vectors of squared length than 1.7*gh. (expected %f)"%(found, _sage_const_p5  * _sage_const_1p7 **(rank /_sage_const_2p )))

save((modulus ,short_vector_list) , 'Dual_short_vectors/dual_short_vectors')


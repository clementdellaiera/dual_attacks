

# This file was *autogenerated* from the file test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_37 = Integer(37); _sage_const_1 = Integer(1); _sage_const_20 = Integer(20); _sage_const_100 = Integer(100); _sage_const_0 = Integer(0); _sage_const_0p1 = RealNumber('0.1'); _sage_const_4 = Integer(4); _sage_const_200 = Integer(200); _sage_const_2 = Integer(2); _sage_const_0p00000001 = RealNumber('0.00000001')
load("Distinguisher/dual_attack.sage")

################
##   BASICS   ##
################

# Generating q-ary lattice of dimension 100 and determinant q**50, where q is a 30 bit prime
n=_sage_const_10 
#AA = IntegerMatrix.random(n , "qary", k = 50 , bits = 30)
## Generating SIS instance
q = _sage_const_37 
AA = random_matrix(Zmod(q),n)

###############
##   TESTS   ## 
###############

# Parameters

n=_sage_const_10 

# LATTICES
print("** LATTICES **")

A = random_matrix(ZZ,n,n)
#s, e = random_vector(ZZ , n ), random_vector(ZZ , n ) 
#t = A*s+e

print("")
print("** BKZ **")

print("norm of first vector of A")
print(A[_sage_const_1 ].norm())

print("BKZ reduction of A")
print("Norm of the first vector of reduced basis : "+str(A.BKZ()[_sage_const_1 ].norm()))

print("")
print("**  DUAL  **") 

# IntegralLattice returns the lattice generated by a quadratic form over ZZ

LL = IntegralLattice(A.transpose() * A) # for integal lattice, there is a direct method
LLv = LL.dual_lattice()
#print(LL.parent())
#print(LL.dual_lattice().parent())

L = A.image()
Av = A * (A.transpose()*A).inverse()
Lv = Av.image() # problem : this is considered a rationnal vector space, not a lattice
w , v = Lv.random_element() , L.random_element()
print(" (w ,v) in ZZ : "+str( w.dot_product(v) in ZZ))

dd = det(A)
B = dd * A.inverse().transpose()
B = B.change_ring(ZZ)
dLv = B.image()
ww , v = (_sage_const_1 /dd) * dLv.random_element() , L.random_element()
print(" (w ,v) in ZZ : "+str( ww.dot_product(v) in ZZ))
vol , Av, Lv = Dual(A)
print("Dual Test : "+str(Lv == (_sage_const_1 /dd) * dLv))
	
ss, (AA,bb) = LWE(_sage_const_20 )	

N = _sage_const_100 	
XX = np.random.normal(_sage_const_0 ,_sage_const_1 ,N)

print("Distinguisher TEST : "+str(Test(XX , _sage_const_0p1 )))

print("")
mm = _sage_const_10  			# rank of lattice
kk = _sage_const_4  				# k first vectors in BKZ reduction of dual basis
TT = _sage_const_10 				# scale of the dual sample
BB = random_matrix(ZZ,mm) 	# Basis of lattice

################################
##    Test for Dual Sampler   ##
################################

print("SAMPLE Test : sample of "+str(TT)+" vectors over dual lattice of rank " + str(mm))

print("Random independant draw with replacement")
SAMPLE = Sample_Dual(BB, kk , TT, "Random_with_replacement")
success = _sage_const_0 
for w in SAMPLE:
	v = BB.image().random_element()
	if (w.dot_product(v) in ZZ):
		success += _sage_const_1 
print("Test (w,v) in ZZ : "+str(_sage_const_100  * success / len(SAMPLE)) + " % success for "+str(len(SAMPLE))+" dual vectors")

print("Random Walk")
SAMPLE = Sample_Dual(BB, kk , TT, "Random_walk")
success = _sage_const_0 
for w in SAMPLE:
	v = BB.image().random_element()
	if (w.dot_product(v) in ZZ):
		success += _sage_const_1 
print("Test (w,v) in ZZ : "+str(_sage_const_100  * success / len(SAMPLE)) + " % success for "+str(len(SAMPLE))+" dual vectors")

print("Sieve")
SAMPLE = Sample_Dual(BB, kk , TT, "Sieve")
success = _sage_const_0 
for w in SAMPLE:
	v = BB.image().random_element()
	if (w.dot_product(v) in ZZ):
		success += _sage_const_1 
print("Test (w,v) in ZZ : "+str(_sage_const_100  * success / len(SAMPLE)) + " % success for "+str(len(SAMPLE))+" dual vectors")
print("")

###############################
##   Test for distinguiser   ##
###############################
print("")
print("DISTINGUISHER test")
tt = LWE_sample(BB,_sage_const_0p1 )
print(Distinguisher_Sieve(BB ,tt, kk,TT))

tt_uniform = vector(RR, normal(_sage_const_0 ,_sage_const_200 ,mm))
print(Distinguisher_Sieve(BB ,tt_uniform, kk,TT))
##################################
##   Hadamard Walsh Transform   ##
##################################

from sympy import fwht
from numpy import cos, linspace
m=_sage_const_10 
t = linspace(_sage_const_0 ,_sage_const_1 ,_sage_const_2 **m)
f = cos(t)
Ff = fwht(f)
e = _sage_const_0p00000001 
print("FAST HADAMARD WALSH TRANSFORM")
print("Check that F**2 = id : "+str(sum(_sage_const_1 *(abs(fwht(Ff)-_sage_const_2 **m * f) < e)) == _sage_const_2 **m ))


